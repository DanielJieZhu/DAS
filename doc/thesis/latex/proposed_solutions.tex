\section{Proposed solutions}
\subsection{Ease of use}

\begin{itemize}
\item Interactive guidance on how to compose queries to ease the learning (could also include some examples of popular queries):
\begin{enumerate}
\item What entity are you searching for?
\item How could you identify it (i.e. what do you know)?
\item After seeing first results: What do you want to do with the results? (list items; select only specific columns; do aggregation; use in command line/another program)
\end{enumerate}

\item (?) JavaScript-based query interpreter to ease query writing: could suggest search attribute and entity attribute names. also taking into account some possible ambiguous namings (auto completion)


\item Keyword query --> ranked list of matching structured queries:
	\begin{itemize}
	\item map keywords to entity name and selection parameters (quite resembling 'Query forms' and 'Keyword cleaning' approaches)
	\item
		{\color{red} Inverted index could be built with help of some good full-text search engine (e.g. Xapian\footnote{http://xapian.org/}) and used to generate mapping to structured queries. If no match found (e.g. new entry not yet in our cache) some pattern matching could be used to try to corresponding guess search attribute}
	\item ranking could be based on: how closely keywords are matching some or all required parameters, popularity of certain query and users feedback
	
	\item {\color{red}	--> evaluate different approaches (HMM, etc); could some natural language processing help?}
	\item special attention to \textbf{wilcard} queries
	
	\end{itemize}
\end{itemize}


\subsection{Performance}
\subsubsection{Continuous view maintenance at Data providers with large DBs}
Use either \textit{materialized refresh fast views with query rewriting} (Oracle; completely transparent for proprietary apps)\cite{Oracle11}
 or some other continuous view maintenance tool (e.g. DBToaster\footnote{http://www.dbtoaster.org that is being developed at EPFL}) to improve performance of heavy queries containing joins and/or aggregations.



\subsubsection{More intelligent caching}
Some of the data entities instances changing very rarely, for example in DBS system old datasets would never change, while new ones are constantly added (still some of their attributes may change, in this example validity).

Cached copy may be shown before hand while up to date results could be retrieved on user's request.

An automatic change rate prediction could be useful to efficiently balance between caching and retrieving results.

Also consider:
                			\begin{itemize}
                			\item given an entity received from provider, determining if it is useful to cache for long-term
%	                			\item \textbf{\color{red}At what level are we caching now? query or individual query results?}
                			\item could cache even \textit{expired} data, but warning user
                			\item could also have different validity dates for certain fields. if no volatile fields are not explicitly requested, even a very old cache could be used. 
                			\item Can we automatically figure which fields are static and which are changing?
                			\item pre-fetching common (sub-)queries: determining manually and/or automatically
                			
                			\item \textbf{Deciding if to cache or not...}

                			\end{itemize}



\subsection{Integrating distributed information efficiently}
Bloom-join (which could be quite transparent and implemented even on DB side [pure SQL is possible for MySQL, to check for Oracle]- take a query and bit-vector as parameter) , lazy pagination (and order required for aggregation) - this is not yet supported by any of the data-service APIs

%\newline
% integration at DAS level. (at source DB could be more performant a little)

